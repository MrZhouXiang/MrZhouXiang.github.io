<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>Android笔记-从ViewGroup的dispatchTouchEvent源码分析事件分发机制 | 我的博客</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/highlight.css"/><link rel="stylesheet" type="text/css" href="/css/font.css"/><link rel="stylesheet" type="text/css" href="/css/noise.css"/><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Android/">Android</a><a class="post-tag-link" href="/tags/源码分析/">源码分析</a></div><div class="post-time">2017-12-07</div></div></div><div class="container post-header"><h1>Android笔记-从ViewGroup的dispatchTouchEvent源码分析事件分发机制</h1></div><div class="container post-content"><p><a href="http://blog.csdn.net/qi1017269990/article/details/79046424" target="_blank" rel="noopener">前一篇文章：浅析了事件拦截机制</a><br>主要是从demo中看的现象总结的结论<br>文中涉及到以下方法</p>
<ol>
<li><p>ViewGroup的三个方法：<br>dispatchTouchEvent：事件分发<br>onInterceptTouchEvent：事件拦截<br>onTouchEvent：事件触发</p>
</li>
<li><p>View的两个方法<br>dispatchTouchEvent：事件分发<br>onTouchEvent：事件触发</p>
</li>
</ol>
<p>而且当时我们忽略了一个方法dispatchTouchEvent<br>其实dispatchTouchEvent这个方法其实才是处理事件分发拦截的主要方法<br>今天我们重点解析此方法。  </p>
<h4 id="Activity中的dispatchTouchEvent"><a href="#Activity中的dispatchTouchEvent" class="headerlink" title="Activity中的dispatchTouchEvent"></a>Activity中的dispatchTouchEvent</h4><p>当我们点击屏幕时候，事件到底怎么传递的呢<br>其实在Activity中也有dispatchTouchEvent方法，我们来看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Activity:</span><br><span class="line"></span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> onUserInteraction();其实是一个空方法，我们忽略。<br>如果getWindow().superDispatchTouchEvent(ev)方法返回的是true，则返回true，否则执行Activity的onTouchEvent(ev);</p>
<p>我们再看如果getWindow().superDispatchTouchEvent(ev)方法，其实是用的抽象类Window中的superDispatchTouchEvent方法，最终实现类是PhoneWindow，我们再看PhoneWindow的superDispatchTouchEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PhoneWindow:</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">    public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>mDecor是一个DecorView，它继承了FrameLayout，其实就是Activity的根view。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DecorView:</span><br><span class="line"></span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       return super.dispatchTouchEvent(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到其实最终触发的是ViewGroup的dispatchTouchEvent。<br>小结：activity中事件传递方向,如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A(Activity)--&gt;|dispatchTouchEvent|B(PhoneWindow)</span><br><span class="line">B--&gt;|superDispatchTouchEvent|C(DecorView)</span><br><span class="line">C--&gt;|superDispatchTouchEvent|D&#123;ViewGroup&#125;</span><br><span class="line">D--&gt;|dispatchTouchEvent|E&#123;ViewGroup&#125;</span><br><span class="line">D--&gt;|dispatchTouchEvent|F(View)</span><br><span class="line">E--&gt;|dispatchTouchEvent|G(ViewGroup)</span><br><span class="line">E--&gt;|dispatchTouchEvent|K(View)</span><br></pre></td></tr></table></figure>
<p>我们看到，最终是由ViewGroup来处理事件的。下面我们重点分析ViewGroup的dispatchTouchEvent方法。</p>
<h4 id="ViewGroup和View中的dispatchTouchEvent"><a href="#ViewGroup和View中的dispatchTouchEvent" class="headerlink" title="ViewGroup和View中的dispatchTouchEvent"></a>ViewGroup和View中的dispatchTouchEvent</h4><h4 id="先看一下伪代码"><a href="#先看一下伪代码" class="headerlink" title="先看一下伪代码:"></a>先看一下伪代码:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup:</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        if(onInterceptTouchEvent(event))&#123;//是否拦截</span><br><span class="line">            return onTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        //没有拦截</span><br><span class="line">        if(child==null)&#123;</span><br><span class="line">            //没有子控件</span><br><span class="line">            return onTouchEvent(event);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             //执行子控件的dispatchTouchEvent</span><br><span class="line">            boolean consume= child.dispatchTouchEvent(event);</span><br><span class="line">            if(!consume)&#123;//子控件没有消费事件，执行当前view的onTouchEvent</span><br><span class="line">                return onTouchEvent(event);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup中：<br>看到:<br>如果onInterceptTouchEvent返回true，则执行当前ViewGroup的onTouchEvent。</p>
<p>如果onInterceptTouchEvent返回false:    如果有子控件，则向下传递事件，执行子控件的dispatchTouchEvent，如果没有子控件，则执行当前ViewGroup的onTouchEvent。</p>
<p>如果子控件的onInterceptTouchEvent返回false，则说明没有消费，当前控件执行onTouchEvent，否则返回false，表示所有子控件都没有消费事件，向上传递。  </p>
<p>如果最上层控件也没有消费事件，则最终交给activity执行onTouchEvent事件。</p>
<p>View中：<br>先看下从ViewGroup中事件向下传递的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//向下传递事件，执行子控件的dispatchTouchEvent</span><br><span class="line">           boolean consume= child.dispatchTouchEvent(event);</span><br><span class="line">           if(!consume)&#123;//子控件没有消费事件，执行当前view的onTouchEvent</span><br><span class="line">               return onTouchEvent(event);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>再看View中的dispatchTouchEvent，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">View:</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码看到，如果child如果是View，则会返回其onTouchEvent(event)方法的结果。当然View中还有<br>还有onTouchListener onClickListener等事件的触发。这些方法我们后面再细细分析。现在我们暂时只关注onTouchEvent方法。<br>该方法如果返回true，则表示view消费了事件，其父控件的onTouchEvent方法将不会触发。<br>如果返回false，父控件则触发onTouchEvent方法并返回onTouchEvent方法的结果。</p>
<h4 id="dispatchTouchEvent源码分析"><a href="#dispatchTouchEvent源码分析" class="headerlink" title="dispatchTouchEvent源码分析"></a>dispatchTouchEvent源码分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">      //验证事件是否连续</span><br><span class="line">      if (mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">          mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</span><br><span class="line">      &#125;</span><br><span class="line">      //这个变量用于记录事件是否被处理完</span><br><span class="line">      boolean handled = false;</span><br><span class="line">      //过滤掉一些不合法的事件：当前的View的窗口被遮挡了。</span><br><span class="line">      if (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">          //如果事件发生的View在的窗口，没有被遮挡</span><br><span class="line">          final int action = ev.getAction();</span><br><span class="line">          //重置前面为0 ，只留下后八位，用于判断相等时候，可以提高性能。</span><br><span class="line">          final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">          //判断是不是Down事件，如果是的话，就要做初始化操作</span><br><span class="line">          if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">              //如果是down事件，就要清空掉之前的状态，比如,重置手势判断什么的。</span><br><span class="line">              //比如，之前正在判断是不是一个单点的滑动，但是第二个down来了，就表示，不可能是单点的滑动，要重新开始判断触摸的手势</span><br><span class="line">              //清空掉mFirstTouchTarget</span><br><span class="line">              // Throw away all previous state when starting a new touch gesture.</span><br><span class="line">              // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">              // due to an app switch, ANR, or some other state change.</span><br><span class="line">              cancelAndClearTouchTargets(ev);</span><br><span class="line">              resetTouchState();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">          //检查是否拦截事件</span><br><span class="line">          final boolean intercepted;</span><br><span class="line">          //如果当前是Down事件，或者已经有处理Touch事件的目标了</span><br><span class="line">          if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                  || mFirstTouchTarget != null) &#123;</span><br><span class="line">              //判断允不允许这个View拦截</span><br><span class="line">              //使用与运算作为判断，可以让我们在flag中，存储好几个标志</span><br><span class="line">              final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">              //如果说允许拦截事件</span><br><span class="line">              if (!disallowIntercept) &#123;</span><br><span class="line">                  //确定是不是拦截了</span><br><span class="line">                  intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                  //重新恢复Action，以免action在上面的步骤被人为地改变了</span><br><span class="line">                  ev.setAction(action); // restore action in case it was changed</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  intercepted = false;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              // There are no touch targets and this action is not an initial down</span><br><span class="line">              // so this view group continues to intercept touches.</span><br><span class="line">              //如果说，事件已经初始化过了，并且没有子View被分配处理，那么就说明，这个ViewGroup已经拦截了这个事件</span><br><span class="line">              intercepted = true;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Check for cancelation.</span><br><span class="line">          //如果viewFlag被设置了PFLAG_CANCEL_NEXT_UP_EVENT ,那么就表示，下一步应该是Cancel事件</span><br><span class="line">          //或者如果当前的Action为取消，那么当前事件应该就是取消了。</span><br><span class="line">          final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class="line">                  || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">          // Update list of touch targets for pointer down, if needed.</span><br><span class="line">          //如果需要（不是取消，也没有被拦截）的话，那么在触摸down事件的时候更新触摸目标列表</span><br><span class="line">          //split代表，当前的ViewGroup是不是支持分割MotionEvent到不同的View当中</span><br><span class="line">          final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class="line">          //新的触摸对象，</span><br><span class="line">          TouchTarget newTouchTarget = null;</span><br><span class="line">          //是否把事件分配给了新的触摸</span><br><span class="line">          boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class="line">          //事件不是取消事件，也没有拦截那么就要判断</span><br><span class="line">          if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">              //如果是个全新的Down事件</span><br><span class="line">              //或者是有新的触摸点</span><br><span class="line">              //或者是光标来回移动事件（不太明白什么时候发生）</span><br><span class="line">              if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                      || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                      || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                  //这个事件的索引，也就是第几个事件，如果是down事件就是0</span><br><span class="line">                  final int actionIndex = ev.getActionIndex(); // always 0 for down</span><br><span class="line">                  //获取分配的ID的bit数量</span><br><span class="line">                  final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                          : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                  // Clean up earlier touch targets for this pointer id in case they</span><br><span class="line">                  // have become out of sync.</span><br><span class="line">                  //清理之前触摸这个指针标识,以防他们的目标变得不同步。</span><br><span class="line">                  removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                  final int childrenCount = mChildrenCount;</span><br><span class="line">                  //如果新的触摸对象为null（这个不是铁定的吗）并且当前ViewGroup有子元素</span><br><span class="line">                  if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</span><br><span class="line">                      final float x = ev.getX(actionIndex);</span><br><span class="line">                      final float y = ev.getY(actionIndex);</span><br><span class="line">                      // Find a child that can receive the event.</span><br><span class="line">                      // Scan children from front to back.</span><br><span class="line">                      //下面所做的工作，就是找到可以接收这个事件的子元素</span><br><span class="line">                      final View[] children = mChildren;</span><br><span class="line">                      //是否使用自定义的顺序来添加控件</span><br><span class="line">                      final boolean customOrder = isChildrenDrawingOrderEnabled();</span><br><span class="line">                      for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                          //如果是用了自定义的顺序来添加控件，那么绘制的View的顺序和mChildren的顺序是不一样的</span><br><span class="line">                          //所以要根据getChildDrawingOrder取出真正的绘制的View</span><br><span class="line">                          //自定义的绘制，可能第一个会画到第三个，和第四个，第二个画到第一个，这样里面的内容和Children是不一样的</span><br><span class="line">                          final int childIndex = customOrder ?</span><br><span class="line">                                  getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                          final View child = children[childIndex];</span><br><span class="line">                          //如果child不可以接收这个触摸的事件，或者触摸事件发生的位置不在这个View的范围内</span><br><span class="line">                          if (!canViewReceivePointerEvents(child)</span><br><span class="line">                                  || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class="line">                              continue;</span><br><span class="line">                          &#125;</span><br><span class="line">                          //获取新的触摸对象，如果当前的子View在之前的触摸目标的列表当中就返回touchTarget</span><br><span class="line">                          //子View不在之前的触摸目标列表那么就返回null</span><br><span class="line">                          newTouchTarget = getTouchTarget(child);</span><br><span class="line">                          if (newTouchTarget != null) &#123;</span><br><span class="line">                              // Child is already receiving touch within its bounds.</span><br><span class="line">                              // Give it the new pointer in addition to the ones it is handling.</span><br><span class="line">                              //如果新的触摸目标对象不为空，那么就把这个触摸的ID赋予它，这样子，</span><br><span class="line">                              //这个触摸的目标对象的id就含有了好几个pointer的ID了</span><br><span class="line"></span><br><span class="line">                              newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                              break;</span><br><span class="line">                          &#125;</span><br><span class="line">                          //如果子View不在之前的触摸目标列表中，先重置childView的标志，去除掉CACEL的标志</span><br><span class="line">                          resetCancelNextUpFlag(child);</span><br><span class="line">                          //调用子View的dispatchTouchEvent,并且把pointer的id 赋予进去</span><br><span class="line">                          //如果说，子View接收并且处理了这个事件，那么就更新上一次触摸事件的信息，</span><br><span class="line">                          //并且为创建一个新的触摸目标对象，并且绑定这个子View和Pointer的ID</span><br><span class="line">                          if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                              // Child wants to receive touch within its bounds.</span><br><span class="line">                              mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                              mLastTouchDownIndex = childIndex;</span><br><span class="line">                              mLastTouchDownX = ev.getX();</span><br><span class="line">                              mLastTouchDownY = ev.getY();</span><br><span class="line">                              newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                              alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">                              break;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //如果newTouchTarget为null，就代表，这个事件没有找到子View去处理它，</span><br><span class="line">                  //那么，如果之前已经有了触摸对象（比如，我点了一张图，另一个手指在外面图的外面点下去）</span><br><span class="line">                  //那么就把这个之前那个触摸目标定为第一个触摸对象，并且把这个触摸（pointer）分配给最近添加的触摸目标</span><br><span class="line">                  if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</span><br><span class="line">                      // Did not find a child to receive the event.</span><br><span class="line">                      // Assign the pointer to the least recently added target.</span><br><span class="line">                      newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                      while (newTouchTarget.next != null) &#123;</span><br><span class="line">                          newTouchTarget = newTouchTarget.next;</span><br><span class="line">                      &#125;</span><br><span class="line">                      newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Dispatch to touch targets.</span><br><span class="line">          //如果没有触摸目标</span><br><span class="line">          if (mFirstTouchTarget == null) &#123;</span><br><span class="line">              // No touch targets so treat this as an ordinary view.</span><br><span class="line">              //那么就表示我们要自己在这个ViewGroup处理这个触摸事件了</span><br><span class="line">              handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                      TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              // Dispatch to touch targets, excluding the new touch target if we already</span><br><span class="line">              // dispatched to it.  Cancel touch targets if necessary.</span><br><span class="line">              TouchTarget predecessor = null;</span><br><span class="line">              TouchTarget target = mFirstTouchTarget;</span><br><span class="line">              //遍历TouchTargt树.分发事件，如果我们已经分发给了新的TouchTarget那么我们就不再分发给newTouchTarget</span><br><span class="line">              while (target != null) &#123;</span><br><span class="line">                  final TouchTarget next = target.next;</span><br><span class="line">                  if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                      handled = true;</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      //是否让child取消处理事件，如果为true，就会分发给child一个ACTION_CANCEL事件</span><br><span class="line">                      final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                              || intercepted;</span><br><span class="line">                      //派发事件</span><br><span class="line">                      if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                              target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                          handled = true;</span><br><span class="line">                      &#125;</span><br><span class="line">                      //cancelChild也就是说，派发给了当前child一个ACTION_CANCEL事件，</span><br><span class="line">                      //那么就移除这个child</span><br><span class="line">                      if (cancelChild) &#123;</span><br><span class="line">                          //没有父节点，也就是当前是第一个TouchTarget</span><br><span class="line">                          //那么就把头去掉</span><br><span class="line">                          if (predecessor == null) &#123;</span><br><span class="line">                              mFirstTouchTarget = next;</span><br><span class="line">                          &#125; else &#123;</span><br><span class="line">                              //把下一个赋予父节点的上一个，这样当前节点就被丢弃了</span><br><span class="line">                              predecessor.next = next;</span><br><span class="line">                          &#125;</span><br><span class="line">                          //回收内存</span><br><span class="line">                          target.recycle();</span><br><span class="line">                          //把下一个赋予现在</span><br><span class="line">                          target = next;</span><br><span class="line">                          //下面的两行不执行了，因为我们已经做了链表的操作了。</span><br><span class="line">                          //主要是我们不能执行predecessor=target，因为删除本节点的话，父节点还是父节点</span><br><span class="line">                          continue;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //如果没有删除本节点，那么下一轮父节点就是当前节点，下一个节点也是下一轮的当前节点</span><br><span class="line">                  predecessor = target;</span><br><span class="line">                  target = next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Update list of touch targets for pointer up or cancel, if needed.</span><br><span class="line">          //遇到了取消事件、或者是单点触摸下情况下手指离开，我们就要更新触摸的状态</span><br><span class="line">          if (canceled</span><br><span class="line">                  || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                  || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">              resetTouchState();</span><br><span class="line">          &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">              //如果是多点触摸下的手指抬起事件，就要根据idBit从TouchTarget中移除掉对应的Pointer(触摸点)</span><br><span class="line">              final int actionIndex = ev.getActionIndex();</span><br><span class="line">              final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">              removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">          mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</span><br><span class="line">      &#125;</span><br><span class="line">      return handled;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上是dispatchTouchEvent源码以及解释。<a href="http://blog.csdn.net/savelove911/article/details/51384603" target="_blank" rel="noopener">参考链接</a></p>
<p>下面我们分析重点逻辑：</p>
<ol>
<li>检查拦截<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//检查是否拦截事件</span><br><span class="line">           final boolean intercepted;</span><br><span class="line">           //如果当前是Down事件，或者已经有处理Touch事件的目标了</span><br><span class="line">           if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                   || mFirstTouchTarget != null) &#123;</span><br><span class="line">               //判断允不允许这个View拦截</span><br><span class="line">               //使用与运算作为判断，可以让我们在flag中，存储好几个标志</span><br><span class="line">               final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">               //如果说允许拦截事件</span><br><span class="line">               if (!disallowIntercept) &#123;</span><br><span class="line">                   //确定是不是拦截了</span><br><span class="line">                   intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                   //重新恢复Action，以免action在上面的步骤被人为地改变了</span><br><span class="line">                   ev.setAction(action); // restore action in case it was changed</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   intercepted = false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // There are no touch targets and this action is not an initial down</span><br><span class="line">               // so this view group continues to intercept touches.</span><br><span class="line">               //如果说，事件已经初始化过了，并且没有子View被分配处理，那么就说明，这个ViewGroup已经拦截了这个事件</span><br><span class="line">               intercepted = true;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>disallowIntercept是用来判断子view是否允许父控件拦截的。子view需要重写requestDisallowInterceptTouchEvent方法，来控制该属性。具体方式还没研究，先不管。只要知道：如果disallowIntercept为true，子控件会告诉父控件不可以拦截，不会走onInterceptTouchEvent方法。当然，我们这里disallowIntercept为false，会执行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用与运算作为判断，可以让我们在flag中，存储好几个标志</span><br><span class="line">         final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">         //如果说允许拦截事件</span><br><span class="line">         if (!disallowIntercept) &#123;</span><br><span class="line">             //确定是不是拦截了</span><br><span class="line">             intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">             //重新恢复Action，以免action在上面的步骤被人为地改变了</span><br><span class="line">             ev.setAction(action); // restore action in case it was changed</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup中的onInterceptTouchEvent方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">       if (ev.isFromSource(InputDevice.SOURCE_MOUSE)//这里不明白</span><br><span class="line">               &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN//事件是按下操作</span><br><span class="line">               &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)//这里不明白</span><br><span class="line">               &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;//这里不明白</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>里面的4个条件现在只看懂一个，暂时认为是return了false吧。没有拦截。这时回到主函数：<strong>intercepted现在是false。表示没有拦截，记住此状态，往下看代码：</strong></p>
<h2 id="事件向下传递与消费"><a href="#事件向下传递与消费" class="headerlink" title="事件向下传递与消费"></a>事件向下传递与消费</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//事件不是取消事件，也没有拦截那么就要判断</span><br><span class="line">            if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">                //如果是个全新的Down事件</span><br><span class="line">                //或者是有新的触摸点</span><br><span class="line">                //或者是光标来回移动事件（不太明白什么时候发生）</span><br><span class="line">                if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                    //这个事件的索引，也就是第几个事件，如果是down事件就是0</span><br><span class="line">                    final int actionIndex = ev.getActionIndex(); // always 0 for down</span><br><span class="line">                    //获取分配的ID的bit数量</span><br><span class="line">                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                    // Clean up earlier touch targets for this pointer id in case they</span><br><span class="line">                    // have become out of sync.</span><br><span class="line">                    //清理之前触摸这个指针标识,以防他们的目标变得不同步。</span><br><span class="line">                    removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                    final int childrenCount = mChildrenCount;</span><br><span class="line">                    //如果新的触摸对象为null（这个不是铁定的吗）并且当前ViewGroup有子元素</span><br><span class="line">                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</span><br><span class="line">                        final float x = ev.getX(actionIndex);</span><br><span class="line">                        final float y = ev.getY(actionIndex);</span><br><span class="line">                        // Find a child that can receive the event.</span><br><span class="line">                        // Scan children from front to back.</span><br><span class="line">                        //下面所做的工作，就是找到可以接收这个事件的子元素</span><br><span class="line">                        final View[] children = mChildren;</span><br><span class="line">                        //是否使用自定义的顺序来添加控件</span><br><span class="line">                        final boolean customOrder = isChildrenDrawingOrderEnabled();</span><br><span class="line">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                            //如果是用了自定义的顺序来添加控件，那么绘制的View的顺序和mChildren的顺序是不一样的</span><br><span class="line">                            //所以要根据getChildDrawingOrder取出真正的绘制的View</span><br><span class="line">                            //自定义的绘制，可能第一个会画到第三个，和第四个，第二个画到第一个，这样里面的内容和Children是不一样的</span><br><span class="line">                            final int childIndex = customOrder ?</span><br><span class="line">                                    getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                            final View child = children[childIndex];</span><br><span class="line">                            //如果child不可以接收这个触摸的事件，或者触摸事件发生的位置不在这个View的范围内</span><br><span class="line">                            if (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //获取新的触摸对象，如果当前的子View在之前的触摸目标的列表当中就返回touchTarget</span><br><span class="line">                            //子View不在之前的触摸目标列表那么就返回null</span><br><span class="line">                            newTouchTarget = getTouchTarget(child);</span><br><span class="line">                            if (newTouchTarget != null) &#123;</span><br><span class="line">                                // Child is already receiving touch within its bounds.</span><br><span class="line">                                // Give it the new pointer in addition to the ones it is handling.</span><br><span class="line">                                //如果新的触摸目标对象不为空，那么就把这个触摸的ID赋予它，这样子，</span><br><span class="line">                                //这个触摸的目标对象的id就含有了好几个pointer的ID了</span><br><span class="line"></span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //如果子View不在之前的触摸目标列表中，先重置childView的标志，去除掉CACEL的标志</span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line">                            //调用子View的dispatchTouchEvent,并且把pointer的id 赋予进去</span><br><span class="line">                            //如果说，子View接收并且处理了这个事件，那么就更新上一次触摸事件的信息，</span><br><span class="line">                            //并且为创建一个新的触摸目标对象，并且绑定这个子View和Pointer的ID</span><br><span class="line">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                                // Child wants to receive touch within its bounds.</span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                                mLastTouchDownX = ev.getX();</span><br><span class="line">                                mLastTouchDownY = ev.getY();</span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果newTouchTarget为null，就代表，这个事件没有找到子View去处理它，</span><br><span class="line">                    //那么，如果之前已经有了触摸对象（比如，我点了一张图，另一个手指在外面图的外面点下去）</span><br><span class="line">                    //那么就把这个之前那个触摸目标定为第一个触摸对象，并且把这个触摸（pointer）分配给最近添加的触摸目标</span><br><span class="line">                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</span><br><span class="line">                        // Did not find a child to receive the event.</span><br><span class="line">                        // Assign the pointer to the least recently added target.</span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        while (newTouchTarget.next != null) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>上面方法大概的意思是：如果事件没有被拦截if (!canceled &amp;&amp; !intercepted) {…}<br>则找到当前点击的子控件并使用dispatchTransformedTouchEvent方法来触发子控件的dispatchTouchEvent方法。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Transforms a motion event into the coordinate space of a particular child view,</span><br><span class="line">     * filters out irrelevant pointer ids, and overrides its action if necessary.</span><br><span class="line">     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</span><br><span class="line">     */</span><br><span class="line">    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">            View child, int desiredPointerIdBits) &#123;</span><br><span class="line">        final boolean handled;</span><br><span class="line"></span><br><span class="line">        // Canceling motions is a special case.  We don&apos;t need to perform any transformations</span><br><span class="line">        // or filtering.  The important part is the action, not the contents.</span><br><span class="line">        final int oldAction = event.getAction();</span><br><span class="line">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                handled = super.dispatchTouchEvent(event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            return handled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Calculate the number of pointers to deliver.</span><br><span class="line">        final int oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">        // If for some reason we ended up in an inconsistent state where it looks like we</span><br><span class="line">        // might produce a motion event with no pointers in it, then drop the event.</span><br><span class="line">        if (newPointerIdBits == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If the number of pointers is the same and we don&apos;t need to perform any fancy</span><br><span class="line">        // irreversible transformations, then we can reuse the motion event for this</span><br><span class="line">        // dispatch as long as we are careful to revert any changes we make.</span><br><span class="line">        // Otherwise we need to make a copy.</span><br><span class="line">        final MotionEvent transformedEvent;</span><br><span class="line">        if (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            if (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                if (child == null) &#123;</span><br><span class="line">                    handled = super.dispatchTouchEvent(event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">                    final float offsetY = mScrollY - child.mTop;</span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line">                return handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Perform any necessary transformations and dispatch.</span><br><span class="line">        if (child == null) &#123;</span><br><span class="line">            handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">            final float offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            if (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Done.</span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>要注意第三个参数child，如果child不为空，则触发child的dispatchTouchEvent方法，如果child为空则会触发自己super的dispatchTouchEvent方法，即view的dispatchTouchEvent方法。</p>
<p>如果dispatchTransformedTouchEvent返回true，则表示子控件消费了事件，会执行以下方法addTouchTarget：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Adds a touch target for specified child to the beginning of the list.</span><br><span class="line">    * Assumes the target child is not already present.</span><br><span class="line">    */</span><br><span class="line">   private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123;</span><br><span class="line">       final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">       target.next = mFirstTouchTarget;</span><br><span class="line">       mFirstTouchTarget = target;</span><br><span class="line">       return target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法会给全局变量<strong>mFirstTouchTarget</strong>来赋值。mFirstTouchTarget是用来控制后续判断的关键变量。<strong>当子控件消费了事件mFirstTouchTarget为非空，当子控件没有消费事件或者被拦截mFirstTouchTarget为空</strong>，继续往下看，是如何用mFirstTouchTarget判断的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Dispatch to touch targets.</span><br><span class="line">           //如果没有触摸目标</span><br><span class="line">           if (mFirstTouchTarget == null) &#123;</span><br><span class="line">               // No touch targets so treat this as an ordinary view.</span><br><span class="line">               //那么就表示我们要自己在这个ViewGroup处理这个触摸事件了</span><br><span class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                       TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Dispatch to touch targets, excluding the new touch target if we already</span><br><span class="line">               // dispatched to it.  Cancel touch targets if necessary.</span><br><span class="line">               TouchTarget predecessor = null;</span><br><span class="line">               TouchTarget target = mFirstTouchTarget;</span><br><span class="line">               //遍历TouchTargt树.分发事件，如果我们已经分发给了新的TouchTarget那么我们就不再分发给newTouchTarget</span><br><span class="line">               while (target != null) &#123;</span><br><span class="line">                   final TouchTarget next = target.next;</span><br><span class="line">                   if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                       handled = true;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       //是否让child取消处理事件，如果为true，就会分发给child一个ACTION_CANCEL事件</span><br><span class="line">                       final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                               || intercepted;</span><br><span class="line">                       //派发事件</span><br><span class="line">                       if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                               target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                           handled = true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       //cancelChild也就是说，派发给了当前child一个ACTION_CANCEL事件，</span><br><span class="line">                       //那么就移除这个child</span><br><span class="line">                       if (cancelChild) &#123;</span><br><span class="line">                           //没有父节点，也就是当前是第一个TouchTarget</span><br><span class="line">                           //那么就把头去掉</span><br><span class="line">                           if (predecessor == null) &#123;</span><br><span class="line">                               mFirstTouchTarget = next;</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               //把下一个赋予父节点的上一个，这样当前节点就被丢弃了</span><br><span class="line">                               predecessor.next = next;</span><br><span class="line">                           &#125;</span><br><span class="line">                           //回收内存</span><br><span class="line">                           target.recycle();</span><br><span class="line">                           //把下一个赋予现在</span><br><span class="line">                           target = next;</span><br><span class="line">                           //下面的两行不执行了，因为我们已经做了链表的操作了。</span><br><span class="line">                           //主要是我们不能执行predecessor=target，因为删除本节点的话，父节点还是父节点</span><br><span class="line">                           continue;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   //如果没有删除本节点，那么下一轮父节点就是当前节点，下一个节点也是下一轮的当前节点</span><br><span class="line">                   predecessor = target;</span><br><span class="line">                   target = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码判断了mFirstTouchTarget：<br>如果mFirstTouchTarget为空，表示没有子控件消费了该事件，需要执行 dispatchTransformedTouchEvent(ev, canceled, null,<br>                        TouchTarget.ALL_POINTER_IDS)方法，这里他的第三个参数为空，前面说过：第三个参数为空，则会执行view的dispatchTouchEvent方法。即把当前ViewGroup视为view来处理事件。<br>如果mFirstTouchTarget不为空，则会遍历TouchTargt树.分发事件。【这里还没搞太懂】源码注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Dispatch to touch targets, excluding the new touch target if we already </span><br><span class="line">// dispatched to it.  Cancel touch targets if necessary.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">翻译:  </span><br><span class="line">发送到触摸目标，如果我们已经发送到它，排除新的触摸目标。如有必要取消触摸目标。</span><br></pre></td></tr></table></figure>
<p>简单理解为：子控件事件分发。而且看代码最终handled一定为true。表示子控件已经消费了事件。 </p>
<p>至此整个dispatchTouchEvent基本分析完毕。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>再看下文章开头的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup:</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        if(onInterceptTouchEvent(event))&#123;//是否拦截</span><br><span class="line">            return onTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果没有拦截</span><br><span class="line">        if(child==null)&#123;</span><br><span class="line">            //没有子控件</span><br><span class="line">            return onTouchEvent(event);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             //执行子控件的dispatchTouchEvent</span><br><span class="line">            boolean consume= child.dispatchTouchEvent(event);</span><br><span class="line">            if(!consume)&#123;//子控件没有消费事件，执行当前view的onTouchEvent</span><br><span class="line">                return onTouchEvent(event);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实源码中是使用mFirstTouchTarget来判断子控件是否消费了事件的。<br>所以伪代码可以改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TouchTarget mFirstTouchTarget=null;//子控件是否消费</span><br><span class="line"></span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">         boolean isIntercept =false;//是否拦截</span><br><span class="line">         if(onInterceptTouchEvent(event))&#123;//是否拦截</span><br><span class="line">            isIntercept=true；</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        if(!isIntercept)&#123;//如果没有拦截</span><br><span class="line">         </span><br><span class="line">            //执行子控件的dispatchTouchEvent</span><br><span class="line">            boolean consume= child.dispatchTouchEvent(event);</span><br><span class="line">            if(!consume)&#123;//子控件没有消费事件</span><br><span class="line">                mFirstTouchTarget = null;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //子控件消费了事件，给mFirstTouchTarget赋值</span><br><span class="line">                mFirstTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;//如果拦截,子控件没有消费事件</span><br><span class="line">        </span><br><span class="line">            mFirstTouchTarget = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(mFirstTouchTarget==null)&#123;</span><br><span class="line">            //子控件没有消费事件</span><br><span class="line">            return onTouchEvent(event);</span><br><span class="line">        &#125;else&#123;//子控件消费了事件</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，如果最终子控件没有消费事件则会执行最上层view的onTouchEvent方法。</p>
<p><a href="http://blog.csdn.net/qi1017269990/article/details/79112498" target="_blank" rel="noopener">下一篇：Android笔记-View中的dispatchTouchEvent和onTouchEvent源码解析</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"/><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>